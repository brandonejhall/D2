model CB

class Date
attributes
    day: Integer init: 1
    month: Integer init: 1
    year: Integer init: 1901

operations
    /** Updates the attribute values */
    initialise(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year := y;
    end
    pre parametersHaveValidValues: isValid(d, m, y)
    post attributesCorrectlyUpdatedAlt:
        (if d = day@pre then day = day@pre else day = d endif) and
            (if m = month@pre then month = month@pre else month = m endif) and
                (if y = year@pre then year = year@pre else year = y endif)

    /* Accessors */
    getDay(): Integer = day
    getMonth(): Integer = month
    getYear(): Integer = year

    /* Mutators - ***** Fill in your OCL expressions and pre- and
                post-conditions for these  from the previous Modelling
                session that asked you to write them. */
    setDay(d: Integer)
    setMonth(m: Integer)
    setYear(y: Integer)

    /** returns true if all the attributes are not null, false otherwise */
    isInitialised(): Boolean =
        day <> null and month <> null and year <> null

    /** returns true if self is before d, , false otherwise */
    before(d: Date): Boolean = true /* ***** Fill in your OCL expression
                from  the previous Modelling session that asked you
                to write it. */

    /** returns true if self has the same values as d, false otherwise */
    equals(d: Date): Boolean = day = d.day and month = d.month and year = d.year
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueConditions:
        let
            s = Set{day = d.day, month = d.month, year = d.month}
        in
            result =  s->excludes(false) /* true or flase will be in result */

    /** returns true if self is after d, false otherwise */
    after(d: Date): Boolean = not equals(d) and not before(d)

    /** returns true if y is a leap year, false otherwise */
    isLeapYear(y: Integer): Boolean =
        if (y.mod(400)=0 or (y.mod(100)>0 and y.mod(4)=0))
        then true
        else false
        endif
    pre yearIsValid: y > 1900

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31

    monthValid(v: Integer): Boolean =  v >= 1 and v <= 12

    yearValid(v: Integer): Boolean = v > 1900

    dayAndMonthValid(d: Integer, m: Integer): Boolean =
        Set{4, 6, 9, 11}->includes(m) implies d < 31

    febValid(d: Integer, y: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and
            (not isLeapYear(y) implies d <= 28)

    isValid(d: Integer, m: Integer, y: Integer): Boolean =
         dayValid(d) and monthValid(m) and yearValid(y) and
            dayAndMonthValid(d, m) and (m = 2 implies febValid(d, y))

constraints
    inv dayValues: dayValid(day)
    inv monthValues: monthValid(month)
    inv yearValues: yearValid(year)
    inv monthsWith30Days: dayAndMonthValid(day, month)
    inv inLeapYearFebDaysCorrect: month = 2 implies febValid(day, year)
end



class DateTime < Date
attributes
    hour: Integer
    minute: Integer
    second: Integer
end


class User 
attributes 
   name: String
   userName: String
   DOB: Date
   email: String
   password: String
   record: Integer derived: 0
   userStatus: UserStatus
   friendsList: Set(User) derived: Set{}
   title: UserTitle
end

class Game < Subject
attributes
 gameResult: GameResult
 time: DateTime
 gameStatus: GameStatus
 gameCreatedOn: DateTime
 Draw: Boolean

end

class LeaderBoard < Observer
end


class Request
attributes
    requestStatus: RequestStatus
    date: DateTime
end

class Blocked
attributes
    isBlocked: Boolean derived: false   
end

class Preference
attributes 
   preferences: Tuple(searchPreference: SearchPreference,userStatus: UserStatus)
end

class RandomMatch
attributes
 searchQueue: DateTime
 regionMatchFound: Boolean derived:false
 searchProgress:SearchProgress 
end

class GameInvite
attributes 
    inviteSatus: InviteStatus 
    Timer: DateTime
end






class CheckersBlitz 
attributes
    CurrentDate: DateTime
end


class Region
attributes
    identity:RegionIdentity
end

class Tournament 
attributes 
 nbrOfPlayers: Integer derived: 0
 nbrOfMatches: Integer derived: 0
 status: TournamentStatus
 winner: String derived: ''
end

class Piece
 attributes
    colour: Colour
    patternType: Pattern
end

class Observer
end

class Subject
end

class King < Piece
end

class MovePattern <OneSquareAny
    attributes 
        patternType: Pattern
end

class OneSquareAny < OneSquareUpDiagonally
end

class OneSquareUpDiagonally
end



class Square
   attributes
    shade:Shade
    column: Column
    row: Row
end

class Move
end

class Board 
end 

associationclass Result 
    between
    User[2] role users
    Game[*] role match ordered
    attributes
        isWinner:Boolean
end

associationclass UserArrangement
    between 
    LeaderBoard[1] role leaderboard
    User[*] role users ordered
    attributes
    placements: Integer derived:0
end

enum RequestStatus{
    Accepted,
    Rejected,
    AwaitingResponse
}

enum SearchPreference{
    Everyone,
    Friends,
    FriendsOfFriends
}

enum RegionIdentity{
    NA,SA,ASIA,EUROPE,OCEANIA,CA,AFRICA
}

enum Colour{
    Red,
    White
}

enum InviteStatus{
    Accepted,
    Rejected,
    AwaitingResponse
}

enum Shade{
    Red,
    White
}
enum GameStatus{
    Ongoing,
    Started,
    Finished
}
enum SearchProgress{
    Found,
    Ongoing,
    Ended
}

enum TournamentStatus{
    Ongoing,
    Intialized,
    Finished
}

enum GameResult{
    Win /* User has won */,
    Lose /* User has Lost*/,
    Draw /* User Draw */
}

enum UserTitle{
    Beginner,
    Novice,
    Intermediate,
    Master,
    GrandMaster
}


enum UserStatus{
    Available,
    FriendsOnly,
    DoNotDisturb
}

enum Pattern{
    OneSquareUp,
    OneSquareAny,
    OneSquareDiagonally
}

enum Row{
    one,two,three,four,five,six,seven,eight
}

enum Column{
    a,b,c,d,e,f,g,h
}


association sets
    between 
    User[1] role user 
    Preference[*] role status
end


composition has
    between 
    Board[1] role board
    Square[64] role squares
end

association pieceLocation
    between
    Square[0..1] role currentPlaceOnBoard
    Piece[0..1] role pieceInSquare
end

composition initialise
    between
    Game[1] role board
    Board[1] role game
end

association joins
    between
    CheckersBlitz[1] role CB
    User[*] role user
end



association promotedTo
    between
    Piece[0..1] role piece
    King[0..1] role king
end

association movesLike
    between 
    Piece[*] role piece
    MovePattern[1..*] role pattern
end

association pieceMoved
    between 
    Piece[1] role piece
    Move[*] role moves ordered
end

association moveCaptured
    between 
    Move[*] role onMove
    Piece[*] role capturedPiece
end

association GameMoves
    between
    Game[1] role game
    Move[*] role moves ordered
end

association MoveTo
    between
    Move[*] role moves
    Square[1..*] role destinationSquare
end

association sends
    between
    User[1] role sender
    Request[*] role sentRequest
end

association respondsTo
    between
    User[1] role receiver
    Request[*] role recievedRequest
end

association updatesBlockedStatus
    between
    User[1] role blocker
    Blocked[*] role updatedBlockStatus
end

association recievesBStausUpdate
    between
    User[1] role blocked
    Blocked[*] role newBlockStatus
end

association observes
    between
    Observer[*] role observer
    Subject[*] role subject
end


association sendGameInvite
between
    User[1] role inviteSender
    GameInvite[*] role sentInvite ordered
end

association reciveGameInvite
between
    User[1] role inviteRecipiant
    GameInvite[*] role receivedInvite ordered
end

association createsInvitedgame
between 
 GameInvite[1] role acceptedInvite 
 Game[0..1] role game
end

association requestRMatch
between
 User[1..*] role userRMrequest
 RandomMatch[*] role MatchSearch
end

association promotedOn
between
    King[0..1] role king
    Move[1] role move
end

association createRMatch
between 
    RandomMatch[1]
    Game[0..1] role RandomGame
end 

association changesTo
between
    Preference[1] role currStatus
    Preference[0..1] role newStatus
end

association RandomSelects
between 
    RandomMatch[*] role foundMatchUp
    User[1] role selectedUser
end

association joinTournament
between 
    User[0..16]
    Tournament[*]
end

association regionSelect
    between
    User[*] role joinedUser
    Region[1] role region
end

association Regionchanged
    between
    Region[1] role currRegion
    Region[0..1] role newRegion
end

aggregation hosts
    between
    Tournament[1] role tournament
    Game[30] role games ordered
end




/* ----------------------------------------------------------------------
    CONSTRAINTS
---------------------------------------------------------------------- */
constraints

context User 
    inv BlockedUsersCannotBeAcceptedAsFriends:
    updatedBlockStatus -> forAll(a | 
        a.isBlocked = true implies( 
            recievedRequest -> select(z| z.requestStatus = 'Accepted') -> excludes(a.blocked)
            )
        )
    inv CannotBlockYourself:
        updatedBlockStatus-> forAll(a |
            a.isBlocked = true implies(
                a.blocked <> self
            )
        )
    inv CannotSendRequestToSelf:
        sentRequest -> forAll(a|
            a.receiver<>self
            )
    inv passwordGreater:
        self.password.size()>11
    inv AgeOver12:
        let bYear = self.DOB.getYear() in 
        (bYear-2022) >11
    inv  CannotBeApartOfYourOwnFriendsList:
        self.friendsList->excludes(self)
    inv max7500Friends:
         sentRequest -> collect(sR | sR.requestStatus = 'Accepted') -> size() < 7501

    inv AcceptedRequestOnFriendsList:
        sentRequest -> forAll(sR | sR.requestStatus = 'Accepted' implies
        self.friendsList->includes(sR.receiver))

    inv OnFriendsListOfUserWhoHaveBeenAccepeted:
        recievedRequest -> forAll (rR | rR.requestStatus = 'Accepted' implies
        self.friendsList-> includes(self))

    inv CannotSendFriendRequestWithAPendingRequest:
        sentRequest.receiver -> forAll( x | sentRequest -> collect(
            O | O.requestStatus = 'Ongoing' and O.receiver = x) -> size() = 1
        )
    inv CannotSendFriendRequestToFriends:
        sentRequest -> forAll(x | x.requestStatus = 'Ongoing' implies 
        self.friendsList->excludes(x.receiver))
        
    inv CannotSendGameInviteToUserInGame:
        sentInvite -> forAll(x| x.inviteSatus = 'AwaitingResponse' implies
        x.inviteRecipiant.match -> forAll(g| g.gameStatus = 'Finished'))
    inv CantSearchForMatchWhileInMatch:
        MatchSearch -> forAll(
            x| x.searchProgress = 'Ongoing' implies match -> collect(
                x| x.gameStatus = 'Ongoing') -> size() = 0)
    inv CannotSendFriendRequestWhenBlocked:
        sentRequest ->forAll(v | v.requestStatus = 'Ongoing' 
            implies 
                v.receiver.updatedBlockStatus -> select( 
                    x | x.isBlocked = true) ->excludes(self)
            ) 
    inv OnlyCanHaveOneOngoingRandomSearch:
        MatchSearch -> collect(z| z.searchProgress = 'Ongoing') -> size() >2

    inv CannotBeRandomlyMatchedUpWithBlockedUser:
        let blockedUsers = updatedBlockStatus -> select(
            x| x.isBlocked = true) in
        MatchSearch -> forAll(
             z| blockedUsers.blocked -> excludes(
                z.selectedUser)
                )




    
    

        
        

        


context CheckersBlitz
    inv UniqueUserNames:
        user -> forAll(a,b|
            a.userName<>b.userName
            )

    inv UniqueEmails:
        user -> forAll(i | let emails = user -> collect(y|
            y.email = i.email) in
                emails->size()=1)
    

context Game
    inv AtMostOneWinner:
    result -> collect (x| x.isWinner = true)-> size() < 2
    inv MatchCantBeDrawnAndWon:
    self.gameStatus = 'Finished' and self.Draw = true implies result -> collect(
        x| x.isWinner = true) -> size() = 0

context Tournament
    inv TournamentGamesCannotBeDrawn:
    games.forAll(x| x.Draw = false)
    inv TournamentEndsWhenWinnerisFound:
    self.status = 'Finished' implies user -> collect(
        x|x.userName)->includes(
            self.winner)



    
context Board
    inv NoTwoSquaresHaveTheSameRowAndColumn: 
    squares -> forAll(a,b| a<>b implies(
        a.row <> b.row and a.column<>b.column))
    inv ExactlyOneRowAndColumnForEachSquare:
    
    let sRow  = Set{'one','two','three','four','five','six','seven','eight'} in
    let sColumn = Set{'a','b','c','d','e','f','g','h'} in

    sRow -> forAll( k| 
    sColumn -> forAll(m| squares -> select(s| 
        s.row = k and s.column = m) -> size() = 1
        )
        )

    